/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var Sent2 = ee.ImageCollection("COPERNICUS/S2"),
    roi = /* color: #d63000 */ee.Geometry.Point([-32.82696533203125, 68.57688745440542]),
    gl1 = /* color: #98ff00 */ee.Geometry.Polygon(
        [[[-33.0054931640625, 68.68796674953718],
          [-33.11260986328125, 68.63399692505128],
          [-33.02471923828125, 68.61297349606234],
          [-32.9285888671875, 68.57989683944567],
          [-32.84619140625, 68.62699130504768]]]),
    gl2 = /* color: #0b4a8b */ee.Geometry.Polygon(
        [[[-33.758056640625, 68.73662470760429],
          [-33.56854248046875, 68.68177387378243],
          [-33.35430908203125, 68.63679560296356],
          [-33.16204833984375, 68.63879655674131],
          [-33.11260986328125, 68.63379383729442],
          [-33.010986328125, 68.68676588280834],
          [-33.1263427734375, 68.9142087845199]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/

Map.setCenter(-33.00,68.64,9);

var date1 = "2018-05-14";
var date2 = "2018-07-31";

var bounds = [gl1, gl2];

var K_glacier = ee.ImageCollection(Sent2
      .filterDate(date1, date2)
      .filterBounds(roi)
      .sort("CloudCoverageAssessment")
      );

Map.addLayer(K_glacier);


//GLACIER FUNCTION-------------

function getLakesData(date1, date2, bounds, roi) {
  //create an array to hold all stats for the images
  var boundary_stats = [];
  //Function to create a mask function for the NDWI to get all water pixels
  var h20mask = function(image) {
      return image.updateMask(image.gt(0.2));
      };

  for(var item in K_glacier) {
  for(var boundary in bounds) {
  //create NDWI for each image in that boundary
  var NDWI = K_glacier.expression(
        "(BLUE - RED) / (BLUE + RED)",
        {
          RED: K_glacier.select("B4"),    // RED
          NIR: K_glacier.select("B8"),    // NIR
          BLUE: K_glacier.select("B2")    // BLUE
        });
  //create a mask function for the NDWI to get all water pixels
  var h20_mask = h20mask(NDWI);
  //Using expression on the masked image to create binary 1 = water, 0 = not water
  var LS_to2 = h20_mask.expression(
    '0 * S2', {
    'S2': h20_mask
      });

  var LS_to3 = LS_to2.expression(
    '1 + S2', {
    'S2': LS_to2
     });
  //Generate the area and stats for the boundary area in the single image, add to an array of
  //boundary areas
  var S1_area = LS_to3.multiply(ee.Image.pixelArea());
  var stats = S1_area.reduceRegion({
      reducer: ee.Reducer.sum(),
      geometry: bounds[boundary],
      scale: 10,
    });
  boundary_stats.push(stats);
    }
  }

  //Function to determine the total area of lakes from all of the boundaries in the study area
  function sumArea(arr) {
    var km_const = 1000000;
    var sum = 0;
    for(var i = 0; i < arr.length; i++) {
      var temp = arr[i].getInfo();
      sum+= temp['constant'];
    }
    return sum/km_const;
  }

  var totalAreaAtDate = sumArea(boundary_stats);
  print(totalAreaAtDate);
  all_sums.push(totalAreaAtDate);
  return totalAreaAtDate;
  //Need an array which has the dates and total area for that date so a plot can be made
  //total area will need to be attached to an object with the property of date, and area of GSL
  //can then be plotted by date
  //ee.Image.date() returns the date of the image.

}


//Function test
var all_sums = [];
result = K_glacier.iterate(getLakesData(date1, date2, bounds, roi), all_sums)


